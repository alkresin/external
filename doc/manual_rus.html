<!DOCTYPE html>
<html lang="ru">
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>External: Справочное руководство</title>
   <meta name="description" content="Руководство по External GUI library">
   <meta name="keywords" content="go,golang,GUI,library,Harbour,HWGUI,guide,документация,программирование">
   <link rel="stylesheet" type="text/css" href="css/table.css">
   <link type="text/css" rel="stylesheet" href="css/shCoreDefault.css"/>
</head>

<body>

<div id="header">
  <div>
    <table width="100%"><tr>
    <td style="text-align: left;"><div id="logo"> External GUI library<br><span class="subt">Александр Кресин, 2018-2021</span> </div></td>
    <td style="text-align: right;"><div>
      <div id="lang">
        <span class="sel">Rus</span> &nbsp;&nbsp; <a href="manual_en.html" class="link">Eng</a>
      </div>
      <div id="d_menu"></div>
    </div></td>
    </tr></table>
  </div>
</div>

<div id="body">
  <div id="content">
    <h1> External: Справочное руководство</h1>
    <ul>
      <li><a name="_Intro" href="#Intro">1.  Введение</a>
      <li><a name="_Hello" href="#Hello">2.  Hello, World</a>
      <li><a name="_Init" href="#Init">3.  Инициализация</a>
      <li><a name="_Crwidg" href="#Crwidg">4.  Создание окон и виджетов</a>
      <ul>
        <li><a name="_Widg1" href="#Widg1">4.1  Структура Widget - описание полей</a>
        <li><a name="_Widg2" href="#Widg2">4.2  Список виджетов</a>
        <li><a name="_Widg3" href="#Widg3">4.3  AProps - дополнительные атрибуты</a>
      </ul>
      <li><a name="_Font" href="#Font">5.  Font, Style</a>
      <li><a name="_cb" href="#cb">6.  Callback функции</a>
      <li><a name="_Metod" href="#Metod">7.  Widget - методы</a>
      <li><a name="_Menu" href="#Menu">8.  Создание меню</a>
      <li><a name="_Func" href="#Func">9.  Функции</a>
      <li><a name="_Print" href="#Print">10.  Печать</a>
      <li><a name="_Pril" href="#Pril">A.  Приложения</a>
      <ul>
        <li><a name="_Pril1" href="#Pril1">Anchor</a>
        <li><a name="_Pril2" href="#Pril2">Winapi стили</a>
        <li><a name="_Pril3" href="#Pril3">Типы бумаги</a>
        <li><a name="_Pril4" href="#Pril4">Типы градиента в Style</a>
        <li><a name="_Pril5" href="#Pril5">Идентификаторы событий</a>
      </ul>
    </ul>
    <br>
    <p><strong class="title"><a name="Intro" href="#_Intro"> 1.  Введение</a></strong></p>
    <p>External - это GUI библиотека для golang, которая для реализации интерфейса использует отдельную
       программу, GuiServer - <a target="_blank" href="http://www.kresin.ru/guisrv.html">см. здесь</a>.</p>
    <p>GuiServer написан на Harbour и GUI-библиотеке HwGUI. Я специально это оговариваю, поскольку в
    дальнейшем буду ссылаться на HwGUI при описании некоторых виджетов.<p>
    <p>При старте External запускает GuiServer, если он еще не запущен, и присоединяется к нему, используя
       два tcp/ip порта. GuiServer может работать как на том же компьютере, что и ваше приложение, так и
       на удаленном - в этом случае запустить его из приложения не удастся, так что он должен быть
       запущен заранее. По одному порту External отправляет команды GuiServer&#39у - создание окон, виджетов,
       всякие действия с ними и пр., по другому - принимает от него сообщения, поступающие при наступлении
       каких либо событий, нажатия кнопки, например.</p>
    <br>
    <p><strong class="title"><a name="Hello" href="#_Hello"> 2.  Hello, World</a></strong></p>
    <p>Начнем, по традиции, с Hello, World. Вот пример простейшей программы, создающей окно с этой надписью:</p>
    <pre class="brush: go;">
package main

import egui "github.com/alkresin/external"

func main() {

    if egui.Init("") != 0 {
        return
    }
    pWindow := &egui.Widget{X: 100, Y: 100, W: 400, H: 140, Title: "My first GUI app"}
    egui.InitMainWindow(pWindow)

    pWindow.AddWidget(&egui.Widget{Type: "label",
        X: 20, Y: 60, W: 160, H: 24, Title: "Hello, World!" })

    pWindow.Activate()
    egui.Exit()
}</pre>
    <p>Функция <i>Init()</i> запускает GuiServer и присоединяется к нему. <i>InitMainWindow()</i> создает
       главное окно приложения с заданными параметрами. Метод AddWidget() — добавляет виджет типа label.
       <i>Activate()</i> — выводит окно на экран и переводит программу в режим ожидания.<p>
    <p>Далее рассмотрим эти действия по порядку.</p>
    <br>

    <p><strong class="title"><a name="Init" href="#_Init"> 3.  Инициализация</a></strong></p>
    <p>Как я уже говорил, первое, что следует сделать - это запустить GuiServer и присоединиться к нему.
       Это делает функция <i>Init(sOpt string)</i>, которой передается строка параметров, разделенных символом
       конца строки ( &quot;\n&quot; ). Вот они (приведены значения по умолчанию):</p>
    <pre>
    guiserver=guiserver.exe
    address=127.0.0.1
    port=3101
    log=0</pre>
    <p>Если вам надо изменить, например, номер порта и уровень журналирования (0...2), вы можете
       использовать такой вызов <i>Init()</i>:</p>
    <pre>
    egui.Init("port=4801\nlog=1")
    </pre>
    <p>Символ конца строки используется в качестве разделителя, чтобы было удобнее передать в
       качестве параметра содержимое ini файла:</p>
    <pre class="brush: go;">
    var sInit string
    b, err := ioutil.ReadFile("test.ini")
    if err != nil {
       sInit = ""
    } else {
       sInit = string(b)
    }

    if egui.Init(sInit) != 0 {
        return
    }
    // ...</pre>
    <p>Функция <i>Init()</i> возвращает 0 в случае успешного выполнения, 1 - если соединиться не удалось,
       и 2 - если протоколы связи вашей версии External и GuiServer отличаются.</p>
    <br>

    <p><strong class="title"><a name="Crwidg" href="#_Crwidg"> 4.  Создание окон и виджетов</a></strong></p>
    <p>Итак, инициализация прошла успешно, теперь мы можем формировать интерфейс программы. В
       большинстве случаев начать следует с создания главного окна. Это делается посредством
       вызова функции <i>InitMainWindow(pWindow)</i>, которой в качестве единственного параметра передается
       указатель на предварительно созданную структуру <i>Widget</i>, описывающую окно. Вот объявление
       этой структуры:</p>
    <pre class="brush: go;">
   type Widget struct {
      Parent   *Widget
      Type     string
      Name     string
      X        int
      Y        int
      W        int
      H        int
      Title    string
      Winstyle int32
      TColor   int32
      BColor   int32
      Tooltip  string
      Anchor   int32
      Font     *Font
      AProps   map[string]string
      aWidgets []*Widget
   }</pre>
    <p>Структура <i>Widget</i> используется для создания окон, диалогов и виджетов, конкретный тип
       объекта определяется полем <i>Type</i>; для главного окна это &quot;main&quot;, для
       диалога - &quot;dialog&quot;, для, например, кнопки, - &quot;button&quot;. К описанию
       полей структуры мы вернемся чуть позже, а пока продолжим разговор о создании окна.</p>
    <p><i>InitMainWindow(pWindow *Widget)</i> создает окно, этот вызов приводит в конечном итоге к вызову на
       стороне GuiServer функции Windows API <i>CreateWindowEx()</i> или, если мы работаем под
       Unix/Linux, <i>gtk_window_new()</i>.</p>
    <p>Для того, чтобы окно появилось на экране, необходимо вызвать еще
       метод объекта <i>Widget Activate()</i>. GuiServer по получении соответствующей команды вызывает функцию
       Windows API <i>ShowWindow()</i> и начинает цикл обработки сообщений, в Unix/Linux делается вызов
       <i>gtk_main()</i>, что, по сути, то же самое. External после отправления команды на GuiServer тоже входит
       в цикл ожидания сообщений, (он принимает их, как вы помните, от GuiServer через второй порт), поэтому
       выполнение программы на этом приостанавливается. Следующие после вызова <i>Activate()</i> для главного окна
       строки программы (точнее, функции, в которой стоит <i>Activate()</i>) будут выполнены только после закрытия
       окна, обычно это завершение программы.</p>
     <p>Для добавления виджетов используется метод объекта <i>Widget AddWidget(pWidg *Widget)</i>. Добавить
        виджет можно в любой другой виджет, но практически нет какого-либо смысла добавлять, например, Edit
        в кнопку. Виджеты добавляются в окно (главное или диалог), на панель, на Tab. При добавлении в окно
        вызовы <i>AddWidget()</i> располагаются между <i>InitMainWindow()</i> и <i>Activate()</i>. При необходимости виджеты
        можно добавлять и в других частях программы при наступлении каких-то событий. Единственным
        параметром <i>AddWidget()</i> является указатель на соответствующую структуру <i>Widget</i>, содержащую описание
        нового виджета</p>
     <br>

     <p><strong class="subhead"><a name="Widg1" href="#_Widg1"> 4.1  Структура Widget - описание полей</a></strong></p>
     <table class="tabl1">
     <tr><td>Parent</td><td> объект Widget, родительское окно/виджет</td>
     <tr><td>Type</td><td> строка, определяющая тип виджета: &quot;main&quot;, &quot;dialog&quot;,
     &quot;button&quot;, &quot;label&quot; и пр., полный список <a href="#Widg2">см. дальше</a></td>
     <tr><td>Name</td><td> строка - идентификатор виджета</td>
     <tr><td>X, Y, W, H</td><td> координаты верхнего левого угла окна/виджета, ширина и высота в пикселях</td>
     <tr><td>Title</td><td> заголовок окна, надпись на кнопке, т.е., текст отображаемый на виджете</td>
     <tr><td>Winstyle</td><td> число, стиль окна/виджета, принятый в Windows API</td>
     <tr><td>TColor, BColor</td><td> число, цвет текста и фона, соответственно</td>
     <tr><td>Tooltip</td><td> он и есть тултип - строчка текста, появляющаяся при наведении мышки на виджет</td>
     <tr><td>Anchor</td><td> якорь, число, определяющее привязку виджета к краям окна при изменении размера окна, подробнее
     <a href="#Pril1">см. в Приложении</a></td>
     <tr><td>Font</td><td> шрифт, объект структуры Font, подробнее <a href="#Font">см. дальше</a></td>
     <tr><td>AProps</td><td> поле типа map, список дополнительных атрибутов окна/виджета, подробнее <a href="#Widg3">см. дальше</a>;</td>
     <tr><td>aWidgets</td><td> массив объектов Widget - тех, что включены в состав этого окна/виджета</td>
     </table>

     <p><strong class="subhead"><a name="Widg2" href="#_Widg2"> 4.2  Список виджетов</a></strong></p>
     <p>В таблице - список типов виджетов (поле Type структуры <i>Widget</i>), поддерживаемых к моменту написания
     этого руководства.</p>
     <table class="tabl1">
     <tr><td>main</td><td> главное окно</td>
     <tr><td>dialog</td><td> диалог</td>
     <tr><td>label</td><td> стандартный статический текст</td>
     <tr><td>edit</td><td> стандартный виджет для ввода/редактирования текста</td>
     <tr><td>button</td><td> стандартная кнопка</td>
     <tr><td>check</td><td> стандартная check - кнопка</td>
     <tr><td>radio</td><td> стандартная радио - кнопка</td>
     <tr><td>radiogr</td><td> группа радио-кнопок</td>
     <tr><td>group</td><td> прямоугольная рамка для выделения группы виджетов</td>
     <tr><td>combo</td><td> стандартный комбобокс</td>
     <tr><td>bitmap</td><td> картинка</td>
     <tr><td>line</td><td> разделительная линия</td>
     <tr><td>panel</td><td> панель (тулбар), на ней можно размещать другие виджеты</td>
     <tr><td>paneltop</td><td> панель, прикрепленная к верхней части окна</td>
     <tr><td>panelbot</td><td> панель, прикрепленная к нижней части окна (статусбар)</td>
     <tr><td>panelhead</td><td> панель - заголовок окна</td>
     <tr><td>ownbtn</td><td> нестандартная кнопка</td>
     <tr><td>splitter</td><td> сплиттер - ну, вы знаете</td>
     <tr><td>updown</td><td> стандартный виджет для редактирования числа с кнопками вверх/вниз</td>
     <tr><td>tree</td><td> дерево</td>
     <tr><td>progress</td><td> прогресс - бар</td>
     <tr><td>tab</td><td> таб с вкладками</td>
     <tr><td>browse</td><td> виджет для отображения таблицы данных</td>
     <tr><td>cedit</td><td> виджет для редактирования текста с расширенными возможностями</td>
     <tr><td>link</td><td> виджет - ссылка</td>
     <tr><td>monthcal</td><td> стандартный календарик</td>
     </table>
     <br>

     <p><strong class="subhead"><a name="Widg3" href="#_Widg3"> 4.3  AProps - дополнительные атрибуты</a></strong></p>
     <p>Поскольку структура <i>Widget</i> - одна для всех типов виджетов, а наборы свойств у виджетов - разные, то
        помимо свойств, общих для большинства виджетов (координаты, текст, цвета, ...), в структуру включена
        хэш-таблица (map) <i>AProps</i>, которая содержит свойства/атрибуты, которые вы хотите установить именно
        для этого виджета. Конечно, вы можете указывать там не всё, что угодно, а только те атрибуты, которые
        определены для виджетов этого типа. Ниже - список типов виджетов с соответствующими свойствами:</p>
     <table class="tabl1">
     <tr><td>main</td><td> Icon: C</td>
     <tr><td>dialog</td><td> Icon: C, NoExitOnEsc: L, NoCloseAble: L</td>
     <tr><td>label</td><td> Transpa: L</td>
     <tr><td>edit</td><td> Picture: C</td>
     <tr><td>check</td><td> Transpa: L</td>
     <tr><td>radio</td><td> Transpa: L</td>
     <tr><td>combo</td><td> AItems: AC</td>
     <tr><td>bitmap</td><td> Transpa: L, TrColor: N, Image: C</td>
     <tr><td>line</td><td> Vertical: L</td>
     <tr><td>panel</td><td> HStyle: C</td>
     <tr><td>paneltop</td><td> HStyle: C</td>
     <tr><td>panelbot</td><td> HStyle: C, AParts: AC</td>
     <tr><td>panelhead</td><td> HStyle: C, Xt: N, Yt: N, BtnClose: L, BtnMax: L, BtnMin: L</td>
     <tr><td>ownbtn</td><td> Transpa: L, TrColor: N, Image: C, HStyles: AC, Xt: N, Yt: N</td>
     <tr><td>splitter</td><td> Vertical: L, From: N, TO: N, ALeft: AC, ARight: AC, HStyle: C</td>
     <tr><td>updown</td><td> From: N, TO: N</td>
     <tr><td>tree</td><td> AImages: AC, EditLabel: L</td>
     <tr><td>progress</td><td> Maxpos: N</td>
     <tr><td>browse</td><td> Append: L, Autoedit: L, NoVScroll: L, NoBorder: L</td>
     <tr><td>cedit</td><td> NoVScroll: L, NoBorder: L</td>
     <tr><td>link</td><td> Link: C, ClrVisited: N, ClrLink: N, ClrOver: N</td>
     <tr><td>monthcal</td><td> NoToday: L, NoTodayCirc: L, WeekNumb: L</td>
     </table>
     <p>Здесь перед двоеточием - имя атрибута, после - его тип:
     <br> - <i>C</i> - строка;
     <br> - <i>N</i> - число;
     <br> - <i>L</i> - логическое значение (boolean);
     <br> - <i>AC</i> - массив строк.
     </p>
     <p>Поскольку <i>AProps</i> имеет тип map[string]string, мы можем значения всех атрибутов указывать только
        как строки. Поэтому числа берем в кавычки, логические значения указываем как &quot;t&quot; и
        &quot;f&quot;, для массивов строк лучше всего использовать функцию <i>ToString(xParam ...interface{})</i>, например:</p>
     <pre>
   AProps: map[string]string{"AItems": egui.ToString("first", "second", "third")}}
   AProps: map[string]string{"Transpa": "t"}}
   AProps: map[string]string{"HStyle": "st2", "BtnClose": "true", "Xt": "60"}}
     </pre>

     <p>Далее - список атрибутов с комментариями (в скобках - значения по умолчанию):</p>
     <table class="tabl1">
     <tr><td>Icon</td><td> </td>
     <tr><td>NoExitOnEsc </td><td> Для диалога: не закрывать диалог при нажатии ESC (Нет)</td>
     <tr><td>NoCloseAble </td><td> </td>
     <tr><td>Transpa </td><td> Прозрачность (Нет)</td>
     <tr><td>TrColor </td><td> Цвет прозрачного слоя</td>
     <tr><td>Picture </td><td> </td>
     <tr><td>AItems </td><td>Для combobox: массив элементов </td>
     <tr><td>Image </td><td> </td>
     <tr><td>Vertical </td><td>Для линии (line): вертикальная или горизонтальная (Нет)</td>
     <tr><td>HStyle </td><td>Стиль - подробнее <a href="#Font">см. дальше</a></td>
     <tr><td>HStyles </td><td> </td>
     <tr><td>AParts </td><td>Для panelbot: массив с размерами (шириной) в пикселях частей панели </td>
     <tr><td>Xt, Yt </td><td> x и y координаты для размещения текста</td>
     <tr><td>BtnClose </td><td>Для panelhead: показать ли кнопку закрытия окна (Да)</td>
     <tr><td>BtnMax </td><td>Для panelhead: показать ли кнопку максимизации окна (Да)</td>
     <tr><td>BtnMin </td><td>Для panelhead: показать ли кнопку минимизации окна (Да) </td>
     <tr><td>From, TO </td><td> </td>
     <tr><td>ALeft, ARight </td><td> </td>
     <tr><td>AImages </td><td> </td>
     <tr><td>EditLabel </td><td> </td>
     <tr><td>Maxpos </td><td> </td>
     <tr><td>Append </td><td>Для browse: можно добавлять строчки (Нет)</td>
     <tr><td>Autoedit </td><td>Для browse: можно редактировать ячейки (Нет)</td>
     <tr><td>NoVScroll </td><td>Без вертикального скролла (Нет)</td>
     <tr><td>NoBorder </td><td>Без окантовки (Нет)</td>
     <tr><td>Link </td><td>Для link: url ссылки</td>
     <tr><td>ClrVisited </td><td>Для link: цвет уже посещенной ссылки</td>
     <tr><td>ClrLink </td><td>Для link: цвет ссылки</td>
     <tr><td>ClrOver </td><td>Для link: цвет ссылки при наведении мыши</td>
     <tr><td>NoToday </td><td>Для monthcal: </td>
     <tr><td>NoTodayCirc </td><td>Для monthcal: </td>
     <tr><td>WeekNumb </td><td>Для monthcal: </td>
     </table>
     <p>Как видите, набор атрибутов, которые можно указать в <i>AProps</i>, невелик. На самом деле список
       атрибутов виджетов HwGUI (и, соответственно, GuiServer) гораздо больше. External позволяет
       установить все эти атрибуты, не поддерживаемые через <i>AProps</i>, с помощью метода <i>SetParam()</i></p>
     <br>

     <p><strong class="title"><a name="Font" href="#_Font"> 5.  Font, Style</a></strong></p>
     <p>Для работы со шрифтами в External предусмотрена структура <i>Font</i>:</p>
     <pre class="brush: go;">
type Font struct {
	Family    string     // наименование шрифта (Arial, Serif, ...)
	Name      string     // идентификатор шрифта
	Height    int        // размер (высота) шрифта
	Bold      bool       // жирный
	Italic    bool       // наклонный
	Underline bool       // подчеркнутый
	Strikeout bool       // перечеркнутый
	Charset   int16      // 204 - русский
}</pre>
     <p>Поля этой структуры, думаю, в комментариях не нуждаются - это стандартные атрибуты шрифта. Поле <i>Name</i>, как
     и в структуре <i>Widget</i>, используется для идентификации шрифта в вашей программе: вы сможете найти
     ранее созданный экземпляр шрифта (указатель на соответствующую структуру <i>Font</i>) с помощью функции <i>GetFont(sName string)</i>.</p>
     <p>Для создания шрифта используется функция <i>CreateFont(pFont *Font)</i>. Она возвращает указатель на
     структуру <i>Font</i> (ту же, что передается ей в качестве параметра), который можно затем использовать при
     объявлении структуры <i>Widget</i> с полем <i>Font</i>. Для изменения шрифта виджета - метод структуры <i>Widget SetFont(pFont *Font)</i>:</p>
     <pre class="brush: go;">
    // Создаем шрифт с идентификатором "flbl"
    egui.CreateFont(&egui.Font{Name: "flbl", Family: "Georgia", Height: 16})
    // Создаем шрифт и указываем его как атрибут диалогового окна
	pFont := egui.CreateFont(&egui.Font{Family: "Georgia", Height: 16})
	pDlg := &egui.Widget{Name: "dlg", X: 300, Y: 200, W: 400, H: 260, Title: "Dialog Test", Font: pFont}
	egui.InitDialog(pDlg)

	pLbl1 := pDlg.AddWidget(&egui.Widget{Type: "label", X: 20, Y: 10, W: 160, H: 24, Title: "Identifier:"})
	// ...
	// Изменяем шрифт метки на созданный ранее с идентификатором "flbl"
	pLbl1.SetFont( egui.GetFont("flbl") )
     </pre>
     <p><i>Style</i> (не путать с <i>Winstyle</i>) - это структура, описывающая вневний вид виджета. Она может
     использоваться для нестандартных виджетов, которые рисуются самим HwGUI: &quot;panel&quot;,
     &quot;paneltop&quot;, &quot;panelbot&quot;, &quot;panelhead&quot;, &quot;ownbtn&quot;.</p>
     <pre class="brush: go;">
type Style struct {
	Name      string    // идентификатор стиля
	Orient    int16     // тип градиента, его направление
	Colors    []int32   // массив цветов для заполнения фона
	Corners   []int32   // массив с радиусами закругления углов, [верхний левый,
	                    //   верхний правый, нижний правый, нижний левый]
	BorderW   int8      // толщина рамки в пикселях, если не задана - рамка
                        //   рисоваться не будет
	BorderClr int32     // цвет рамки
	Bitmap    string    // картинка для заполнения фона
}</pre>
     <p> Главным образом <i>Style</i> используется для создания градиентного фона виджета. Поле
     <i>Colors</i> - массив цветов градиента, Orient - направление <a href="#Pril4"> подробнее см. дальше</a>.</p>
     <p>Поле <i>Name</i>, как и в структурах <i>Widget</i> и <i>Font</i>, используется для идентификации
     стиля в вашей программе: вы сможете найти ранее созданный экземпляр стиля (указатель на
     соответствующую структуру <i>Style</i>) с помощью функции <i>GetStyle(sName string)</i>.</p>
     <p>Для создания стиля используется функция <i>CreateStyle(pStyle *Style)</i>. Она возвращает указатель на
     структуру <i>Style</i> (ту же, что передается ей в качестве параметра), который можно затем использовать при
     объявлении структуры <i>Widget</i> в составе хэш-массива <i>AProps</i>. Ключом соответствующего
     элемента будет <i>HStyle</i>, а значением - идентификатор (<i>Name</i>) структуры <i>Style</i>.</p>
     <p></p>
     <br>

     <p><strong class="title"><a name="cb" href="#_cb"> 6.  Callback функции</a></strong></p>
     <p>Callback функции (функция обратного вызова) - одно из важнейших понятий в External, это основная часть вашего
     приложения. В главной функции (<i>main()</i>) вы обычно создаете главное окно, его меню, набор
     виджетов. После вызова <i>Activate()</i> выполнение программы приостанавливается, она переходит в
     режим ожидания сообщений от GuiServer, от GUI-элементов вашего окна, вашего интерфейса. Эти
     сообщения вызывают выполнение callback функций вашего приложения, тех функций, которые вы
     установили как callback. Это функции, указанные в объявлении пунктов меню
     (<i>AddMenuItem()</i>), переданные c помощью <i>SetCallBackProc()</i> для обработки того или иного
     события (нажатия кнопки, потери фокуса ввода, ...), установленные для вызова после закрытия
     стандартного диалога (<i>MsgInfo()</i>, <i>SelectFile()</i>, ...), ...</p>
     <p>Спецификация callback функции имеет вид <i>func([]string) string</i>, т.е. она принимает в
     качестве параметра массив строк и возвращает строку. В функциях, которые предназначены для
     передачи на GuiServer информации о callback функции, используются для этого два параметра:
     <i>fu func([]string) string</i> и <i>sCode string</i>. Первый - та самая callback
     функция, второй - идентификатор этой функции (это может быть имя функции или любая другая
     уникальная строка). External строит хэш-массив <i>map[string]func([]string) string</i> и
     передает на GuiServer строковый идентификатор. GuiServer при наступлении соответствующего
     события этот идентификатор возвращает, External находит по нему нужную функцию в хэш-массиве
     и выполняет ее. Вот так это и работает. Идентификатор нужен для того, чтобы передавать его
     на GuiServer и обратно - как, например, имя (<i>sName</i>) структур <i>Widget</i>, <i>Font</i> и пр.
     Кроме функции и ее идентификатора может передаваться произвольное количество строковых
     параметров - они будут потом переданы обратно callback - функции.</p>
     <p>Вот как это может выглядеть в программе:</p>
     <pre class="brush: go;">
     ...
     // Передается ссылка на объявленную в программе функцию fu1
     egui.AddMenuItem("Date", 0, fu1, "fu1" )
     ...
     // Анонимная Callback функция, "Bye...1" - параметр, который она получит в массиве
     egui.AddMenuItem("Set text to label", 0,
        func(p []string) string { egui.Widg("main.l1").SetText(p[1]); return "" },
         "fsett2", "Bye...1")
     ...
     // Callback функция fsett1, которая будет вызвана при нажатии pButton
     pButton.SetCallBackProc("onclick", fsett1, "fsett1", "first parameter")
     </pre>
     <p>При вызове callback функции из меню первым элементом в передаваемом обратно параметре-массиве
     всегда будет строка &quot;menu&quot;, при вызове от какого-либо виджета - идентификатор
     этого виджета. Т.е., в приведенном выше примере в функции <i>fu1(p []string)</i> массив <i>p</i> будет
     содержать единственный элемент &quot;menu&quot;, а в функции <i>fsett1</i> - два элемента:
     идентификатор <i>pButton</i> (<i>sName</i>) и строка &quot;first parameter&quot;.</p>
     <p>Кроме функции, объявленной в вашем приложении, можно также использовать в качестве
     callback функции программный код, написанный на Harbour. Для этого вместо функции указываете nil, а
     вместо ее идентификатора - строку кода. В этом случае событие обрабатывается на GuiServer и
     в ваше приложение ничего не передаётся:</p>
     <pre class="brush: go;">
     ...
     // Вызов Harbour/HwGUI функции hwg_EndWindow(), которая закрывает главное окно
     egui.AddMenuItem("Exit", 0, nil, "hwg_EndWindow()")
     ...
     // В 1-ую часть нижней панели (panelbot) главного окна пишется текущая дата
     pButton.SetCallBackProc("onclick", nil, "hwg_WriteStatus(HWindow():GetMain(),1,Dtoc(Date()),.T.)")
     </pre>
     <br>

     <p><strong class="title"><a name="Metod" href="#_Metod"> 7.  Widget - методы</a></strong></p>
     <p></p>
     <table class="tabl2">
     <tr><td>Activate() bool </td><td>Активирует главного окно или диалог </td>
     <tr><td>Close() bool </td><td>Закрывает главное окно или диалог </td>
     <tr><td>AddWidget(pWidg *Widget) *Widget </td><td>Добавляет виджет </td>
     <tr><td>SetText(sText string) </td><td>Устанавливает текст виджета </td>
     <tr><td>SetImage(sImage string) </td><td>Для виджета &quot;bitmap&quot; - изменить картинку, в качестве параметра передается путь и имя файла изображения </td>
     <tr><td>SetParam(sParam string, xParam interface{}) </td><td> </td>
     <tr><td>GetText() string </td><td>Возвращает текст виджета </td>
     <tr><td>SetColor(tColor int32, bColor int32) </td><td>Устанавливает цвет текста и фона виджета </td>
     <tr><td>SetFont(pFont *Font) </td><td>Устанавливает шрифт виджета </td>
     <tr><td>SetCallBackProc(sbName string,<br> &nbsp;&nbsp;fu func([]string) string, sCode string,<br> &nbsp;&nbsp;params ...string) </td>
       <td>Устанавливает callback процедуру для виджета, <i>sbName</i> - <a href="#Pril5">идентификатор события</a>, для которого
           устанавливается процедура, подробнее о callback функциях <a href="#cb">см. выше</a>.</td>
     <tr><td>SetCallBackFunc(sbName string,<br> &nbsp;&nbsp;fu func([]string) string, sCode string,<br> &nbsp;&nbsp;params ...string) </td>
       <td>Устанавливает callback функцию для виджета, <i>sbName</i> - <a href="#Pril5">идентификатор события</a>, для которого
           устанавливается процедура, подробнее о callback функциях <a href="#cb">см. выше</a>. </td>
     <tr><td>Move(iLeft, iTop, iWidth, iHeight int32) </td><td>Перемещает виджет и/или изменяет его размер </td>
     <tr><td>Enable(bEnable bool) </td><td>Enable или Disable виджет, в зависимости от параметра bEnable </td>
     <tr><td>Hide(bHide bool) </td><td>Спрятать или показать виджет - в зависимости от параметра bHide </td>
     </table>
     <br>

     <p><strong class="title"><a name="Menu" href="#_Menu"> 8.  Создание меню</a></strong></p>
     <p>Главное меню программы создается между вызовами <i>InitMainWindow()</i> и <i>Activate()</i>,
        для этого используются функции <i>Menu(sTitle string)</i>, <i>EndMenu()</i>,
        <i>AddMenuItem(sName string, id int, fu func([]string) string, sCode string, params ...string)</i>,
        <i>AddMenuSeparator()</i>. Фигурные скобки после <i>Menu()</i> необязательны, они добавлены здесь для
        большей выразительности.</p>
     <pre class="brush: go;">
package main

import (
    "time"
    egui "github.com/alkresin/external"
)

func main() {

    if egui.Init("") != 0 {
        return
    }

    pWindow := &(egui.Widget{X: 100, Y: 100, W: 400, H: 280, Title: "GUI for Golang"})
    egui.InitMainWindow(pWindow)

    // Создание меню начинается с вызва функции Menu("")
    // с пустым заголовком
    egui.Menu("")
    {
        // Субменю тоже создается с помощью вызова Menu(),
        // но уже с текстом заголовка
        egui.Menu("File")
        {
            // Добавляем пункт меню
            // fu1() - callback функция, которая должна выполняться при
            // выборе этого пункта меню
            egui.AddMenuItem("Date", 0, fu1, "fu1" )
            // Добавляем разделитель
            egui.AddMenuSeparator()
            // Здесь в качестве callback-функции указывается Harbour-код,
            // который будет выполняться на GuiServer.
            // Здесь это функция, которая закрывает главно окно.
            egui.AddMenuItem("Exit", 0, nil, "hwg_EndWindow()")
        }
        egui.EndMenu()
        egui.Menu("Help")
        {
            egui.AddMenuItem("About", 0, nil,
                "hwg_MsgInfo(\"My Golang GUI application\"+chr(10)+chr(13)+hwg_version(),\"About\")")
        }
        egui.EndMenu()
    }
    egui.EndMenu()

    pWindow.Activate()
    egui.Exit()
}

func fu1([]string) string {

    egui.MsgInfo("Today is " + time.Now().Format("02.01.2006"), "Info", nil, "", "")
    return ""
}</pre>
     <br>

     <p><strong class="title"><a name="Func" href="#_Func"> 9.  Функции</a></strong></p>
     <p></p>
     <table class="tabl2">
      <tr><td>InitMainWindow(pWnd *Widget) bool </td><td>Создает главное окно </td>
      <tr><td>InitDialog(pWnd *Widget) bool </td><td>Создает диалоговое окно </td>
      <tr><td>BeginPacket() </td><td>Начало пакетной передачи данных </td>
      <tr><td>EndPacket() </td><td>Завершение пакетной передачи данных </td>
      <tr><td>WriteLog(sText string) </td><td>Добавляет строку в файл egui.log </td>
      <tr><td>GetFont(sName string) *Font </td><td>Ищет по имени в списке созданных в программе шрифтов, возвращает найденный указатель на структуру Font </td>
      <tr><td>GetStyle(sName string) *Style </td><td>Ищет по имени в списке созданных в программе стилей, возвращает найденный указатель на структуру Style </td>
      <tr><td>Wnd(sName string) *Widget </td><td>Ищет по имени в списке созданных в программе окон, возвращает найденный указатель на структуру Widget </td>
      <tr><td>Widg(sName string) *Widget </td><td>Ищет по имени в списке созданных в программе виджетов, возвращает найденный указатель на структуру Widget </td>
      <tr><td>ToString(xParam ...interface{}) string </td><td>Преобразует параметры в json-строку для отправки на GuiServer </td>
      <tr><td>OpenMainForm(sForm string) bool </td><td>Открывает xml форму с описанием главного окна, предварительно подготовленную с помощью HwGUI Designer </td>
      <tr><td>OpenForm(sForm string) bool </td><td>Открывает xml форму с описанием диалогового окна, предварительно подготовленную с помощью HwGUI Designer </td>
      <tr><td>OpenReport(sForm string) bool </td><td>Открывает xml форму с описанием отчета, предварительно подготовленную с помощью HwGUI Designer </td>
      <tr><td>CreateFont(pFont *Font) *Font </td><td>Создает шрифт на основе структуры Font </td>
      <tr><td>CreateStyle(pStyle *Style) *Style </td><td>Создает стиль на основе структуры Style </td>
      <tr><td>CreateHighliter(sName string, sCommands string,<br>&nbsp;&nbsp;&nbsp;sFuncs string,
                 sSingleLineComm string,<br>&nbsp;&nbsp;&nbsp;sMultiLineComm string, bCase bool) *Highlight </td>
         <td> </td>
      <tr><td>SetHighliter(pEdit *Widget, p *Highlight) </td><td> </td>
      <tr><td>SetHiliOpt(pEdit *Widget, iGroup int,<br>&nbsp;&nbsp;&nbsp;pFont *Font, tColor int32, bColor int32) </td>
         <td> </td>
      <tr><td>InitPrinter(pPrinter *Printer, sFunc string,<br>&nbsp;&nbsp;&nbsp;fu func([]string) string, sMark string) *Printer </td>
         <td>Инициализирует принтер - <a href="#Print">подробнее см. здесь</a>. </td>
      <tr><td>EvalProc(s string) </td><td>Передает на GuiServer для выполнения программный код на языке Harbour</td>
      <tr><td>EvalFunc(s string) []byte </td><td>Передает на GuiServer для выполнения программный код на языке Harbour, возвращает результат </td>
      <tr><td>GetValues(pWnd *Widget, aNames []string) []string </td><td>Возвращает массив строк - значений
         виджетов окна <i>pWnd</i>, перечисленных по идентификаторам в массиве <i>aNames</i>. </td>
      <tr><td>GetVersion(i int) string </td><td>Возвращает версию GuiServer. Если i==0 - номер версии, i==1 - полную строку с номером версии, i==2 - версию GuiServer, HwGUI и Harbour</td>
      <tr><td>MsgInfo(sMessage string, sTitle string,<br>&nbsp;&nbsp;&nbsp;fu func([]string) string, sFunc string, sName string) </td>
         <td>Создает стандартный Info диалог. <i>sMessage</i> - текст сообщения, <i>sTitle</i> - заголовок окна;<br><i>fu</i>, <i>sFunc</i> - callback функция
             и ее идентификатор, эта функция вызывается после закрытия диалога; <i>sName</i> - эта строка будет первой в массиве, передаваемом callback
             функции при ее вызове.</td>
      <tr><td>MsgStop(sMessage string, sTitle string,<br>&nbsp;&nbsp;&nbsp;fu func([]string) string, sFunc string, sName string) </td>
         <td>Создает стандартный Stop диалог. Параметры те же, что и в MsgInfo.</td>
      <tr><td>MsgYesNo(sMessage string, sTitle string,<br>&nbsp;&nbsp;&nbsp;fu func([]string) string, sFunc string, sName string) </td>
         <td>Создает стандартный YesNo диалог. Параметры те же, что и в MsgInfo.</td>
      <tr><td>MsgGet(sMessage string, sTitle string, iStyle int32,<br>&nbsp;&nbsp;&nbsp;fu func([]string) string, sFunc string, sName string) </td>
         <td>Создает диалог для ввода строки. Параметры те же, что и в MsgInfo, <i>iStyle</i> - стиль виджета
             Edit. Возвращает введенную строку.</td>
      <tr><td>Choice(arr []string, sTitle string,<br>&nbsp;&nbsp;&nbsp;fu func([]string) string, sFunc string, sName string) </td>
         <td> </td>
      <tr><td>SelectFile(sPath string,<br>&nbsp;&nbsp;&nbsp;fu func([]string) string, sFunc string, sName string) </td>
         <td> </td>
      <tr><td>SelectFolder(fu func([]string) string,<br>&nbsp;&nbsp;&nbsp;sFunc string, sName string) </td>
         <td> </td>
      <tr><td>SelectColor(iColor int32,<br>&nbsp;&nbsp;&nbsp;fu func([]string) string, sFunc string, sName string) </td>
         <td> </td>
      <tr><td>SelectFont(fu func([]string) string,<br>&nbsp;&nbsp;&nbsp;sFunc string, sName string) </td>
         <td> </td>
      <tr><td>InsertNode(pTree *Widget, sNodeName string,<br>&nbsp;&nbsp;&nbsp;sNodeNew string, sTitle string,
                sNodeNext string,<br>&nbsp;&nbsp;&nbsp;aImages []string, fu func([]string) string, sCode string) </td>
         <td> </td>
      <tr><td>SelectNode(pTree *Widget, sNodeName string) </td><td> </td>
      <tr><td>PBarStep(pPBar *Widget) </td><td> </td>
      <tr><td>PBarSet(pPBar *Widget, iPos int) { </td><td> </td>
      <tr><td>InitTray(sIcon string, sMenuName string, sTooltip string) </td><td> </td>
      <tr><td>ModifyTrayIcon(sIcon string) </td><td> </td>
      <tr><td>RadioEnd(p *Widget, iSel int) </td><td> </td>
      <tr><td>TabPage(pTab *Widget, sCaption string) </td><td> </td>
      <tr><td>TabPageEnd(pTab *Widget) </td><td> </td>
      <tr><td>BrwSetArray(p *Widget, arr *[][]string) </td><td> </td>
      <tr><td>BrwGetArray(p *Widget) [][]string </td><td> </td>
      <tr><td>BrwSetColumn(p *Widget, ic int, sHead string,<br>&nbsp;&nbsp;&nbsp;iAlignHead int, iAlignData int,
                 bEditable bool, iLength int) </td><td> </td>
      <tr><td>BrwSetColumnEx(p *Widget, ic int, sParam string, xParam interface{}) </td><td> </td>
      <tr><td>BrwDelColumn(p *Widget, ic int) </td><td> </td>
      <tr><td>SetVar(sVarName string, sValue string) </td><td>Создает на GuiServer Public переменную <i>sVarName</i> (если ее нет) и устанавливает ее значение <i>sValue</i></td>
      <tr><td>GetVar(sVarName string) string </td><td>Возвращает с GuiServer значение переменной <i>sVarName</i></td>
      <tr><td>SetImagePath(sValue string) </td><td>Передает на GuiServer путь по умолчанию для файлов изображений</td>
      <tr><td>SetPath(sValue string) </td><td>Передает на GuiServer путь по умолчанию для чтения/записи файлов </td>
      <tr><td>SetDateFormat(sValue string) </td><td>Передает на GuiServer желаемый формат вывода даты </td>
      <tr><td>Menu(sTitle string) </td><td>Начинает объявление меню или субменю </td>
      <tr><td>MenuContext(sName string) </td><td>Начинает объявление контекстного меню </td>
      <tr><td>ShowMenuContext(sName string, pWnd *Widget) </td><td> </td>
      <tr><td>EndMenu() </td><td>Завершает объявление меню или субменю </td>
      <tr><td>AddMenuItem(sName string, id int, fu func([]string) string,<br>&nbsp;&nbsp;&nbsp;sCode string, params ...string) </td>
         <td> </td>
      <tr><td>AddCheckMenuItem(sName string, id int,<br>&nbsp;&nbsp;&nbsp;fu func([]string) string, sCode string, params ...string) </td>
         <td> </td>
      <tr><td>AddMenuSeparator() </td><td>Добавляет в меню линию-разделитель </td>
      <tr><td>MenuItemEnable(sWndName string, sMenuName string,<br>&nbsp;&nbsp;&nbsp;iItem int, bValue bool) </td>
         <td> </td>
      <tr><td>MenuItemCheck(sWndName string, sMenuName string,<br>&nbsp;&nbsp;&nbsp;iItem int, bValue bool) </td>
         <td> </td>
     </table>
     <br>

     <p><strong class="title"><a name="Print" href="#_Print"> 10.  Печать</a></strong></p>
     <p>Первое, что надо сделать при при создании печатного документа - это создать структуру <i>Printer</i>, которая
        имеет следующий вид:</p>
     <pre class="brush: go;">
type Printer struct {
	Name       string      // Идентификатор принтера
	SPrinter   string      // Имя принтера
	BPreview   bool        // True, если нужно превью
	IFormType  int         // Тип бумаги, <a href="#Pril3">см. в Приложении</a>, по умолчанию - DMPAPER_A4
	BLandscape bool        // True, если нужна альбомная ориентация
}</pre>
     <p>Здесь <i>Name</i> - идентификатор принтера, поле, аналогичное таким же идентификаторам в <i>Widget</i>, <i>Font</i>, <i>Style</i>. <i>SPrinter</i> - имя
        принтера в системе. Если <i>SPrinter</i> не указан, будет использоваться принтер по умолчанию; если
        его значение - &quot;...&quot;, то появится стандартное диалоговое окно для выбора принтера. </p>
     <p>Затем инициализируем принтер с помощью функции <i>InitPrinter()</i>, которой передаем созданную структуру.</p>
     <pre>
     InitPrinter(pPrinter *Printer, sFunc string, fu func([]string) string, sMark string) *Printer
     </pre>
     <p>Параметры <i>sFunc</i>, <i>fu</i>, <i>sMark</i> (те же, что в функциях, вызывающих стандартные диалоги), используются в
        тех случаях, когда поле <i>Sprinter</i> структуры <i>Printer</i> равно &quot;...&quot;, т.е., требуется стандартный
        диалог выбора принтера. Напомню, <i>fu</i> - функция, которая должна быть вызвана по завершении диалога, <i>sFunc</i> - ее
        идентификатор, <i>sMark</i> - первый элемент массива строк, который будет передан этой функции.</p>
     <p>После инициализации принтера можно приступать к печати. Ниже - список методов структуры <i>Printer</i>, которые
        при этом используются: </p>
     <table class="tabl2">
       <tr><td>AddFont(pFont *Font) *Font </td><td>Добавляет шрифт </td>
       <tr><td>SetFont(pFont *Font) </td><td>Устанавливает текущий шрифт для печати </td>
       <tr><td>Say(iTop, iLeft, iRight, iBottom int32, sText string, iOpt int32) </td><td>Печатает
          текст <i>sText</i> в прямоугольной области с координатами <i>iTop</i>, <i>iLeft</i>, <i>iRight</i>, <i>iBottom</i>. <i>iOpt</i> - тип
          выравнивания ( <i>DT_LEFT</i>, <i>DT_RIGHT</i>, <i>DT_CENTER</i> ) </td>
       <tr><td>Line(iTop, iLeft, iRight, iBottom int32) </td><td>Рисует линию в заданных координатах </td>
       <tr><td>Box(iTop, iLeft, iRight, iBottom int32) </td><td>Рисует прямоугольник в заданных координатах </td>
       <tr><td>StartPage() </td><td>Начинает новую страницу печати, этот вызов обязателен. </td>
       <tr><td>EndPage() </td><td>Завершает печать страницы, этот вызов обязателен. </td>
       <tr><td>End() </td><td>Завершает печать, освобождает принтер. </td>
     </table>
     <p>Все координаты указаны в миллиметрах.</p>
     <p>Вот пример печати одной простой страницы:</p>
     <pre class="brush: go;">
func fprint(p []string) string {
    // Функция первоначально вызывается из главного меню
	if p[0] == "menu" {
		egui.InitPrinter(&egui.Printer{SPrinter: "...", BPreview: true}, "fprint", fprint, "mm1")
	} else {
	    // Повторно она же вызывается после выбора принтера из стандартного диалога
		pPrinter := egui.PLastPrinter
		pFont := pPrinter.AddFont(&egui.Font{Family: "Times New Roman", Height: 10})
		pPrinter.StartPage()
		pPrinter.SetFont(pFont)
		pPrinter.Box(5, 5, 200, 282)
		pPrinter.Say(50, 10, 165, 26, "Printing first sample !", egui.DT_CENTER)
		pPrinter.Line(45, 30, 170, 30)
		pPrinter.Line(45, 5, 45, 30)
		pPrinter.Line(170, 5, 170, 30)
		pPrinter.Say(50, 120, 150, 132, "----------", egui.DT_CENTER)
		pPrinter.Box(50, 134, 160, 146)
		pPrinter.Say(50, 135, 160, 146, "End Of Report", egui.DT_CENTER)
		pPrinter.EndPage()
		pPrinter.End()
	}
	return ""
}</pre>
     <br>

     <p><strong class="title"><a name="Pril" href="#_Pril"> A.  Приложения</a></strong></p>
     <p><strong class="subhead"><a name="Pril1" href="#_Pril1"> Anchor</a></strong></p>
     <p>Список возможных значений поля Anchor структуры Widget:</p>
     <table class="tabl1">
	  <tr><td>A_TOPLEFT</td><td> = -1  // Anchors control to the top and left borders of the container and does not change the distance between the top and left borders. (Default)</td>
	  <tr><td>A_TOPABS</td><td> = 1   // Anchors control to top border of container and does not change the distance between the top border.</td>
	  <tr><td>A_LEFTABS</td><td> = 2   // Anchors control to left border of container and does not change the distance between the left border.</td>
	  <tr><td>A_BOTTOMABS</td><td> = 4   // Anchors control to bottom border of container and does not change the distance between the bottom border.</td>
	  <tr><td>A_RIGHTABS</td><td> = 8   // Anchors control to right border of container and does not change the distance between the right border.</td>
	  <tr><td>A_TOPREL</td><td> = 16  // Anchors control to top border of container and maintains relative distance between the top border.</td>
	  <tr><td>A_LEFTREL</td><td> = 32  // Anchors control to left border of container and maintains relative distance between the left border.</td>
	  <tr><td>A_BOTTOMREL</td><td> = 64  // Anchors control to bottom border of container and maintains relative distance between the bottom border.</td>
	  <tr><td>A_RIGHTREL</td><td> = 128 // Anchors control to right border of container and maintains relative distance between the right border.</td>
	  <tr><td>A_HORFIX</td><td> = 256 // Anchors center of control relative to left and right borders but remains fixed in size.</td>
	  <tr><td>A_VERTFIX</td><td> = 512 // Anchors center of control relative to top and bottom borders but remains fixed in size.</td>
	  </table>
	  <p>Эти значения можно комбинировать. Например, <i>egui.A_LEFTABS+egui.A_RIGHTABS</i> - такой виджет, привязанный
	     к левому и правому краям, будет растягиваться в ширину при растягивании окна.</p>
	  <br>
	
     <p><strong class="subhead"><a name="Pril2" href="#_Pril2"> WinAPI стили</a></strong></p>
     <table class="tabl1">
      <tr><td>DT_LEFT </td><td> Выравнивание влево</td>
      <tr><td>DT_CENTER </td><td> Выравнивание вправо</td>
      <tr><td>DT_RIGHT </td><td> Выравнивание по центру</td>
      <tr><td>ES_PASSWORD </td><td> Ввод пароля (для Edit)</td>
      <tr><td>ES_MULTILINE </td><td> Многострочный Edit</td>
      <tr><td>ES_READONLY </td><td> Edit - только для чтения</td>
      <tr><td>WS_HSCROLL </td><td> Горизонтальный скролл</td>
      <tr><td>WS_VSCROLL </td><td> Вертикальный скролл</td>
      <tr><td>WND_NOTITLE </td><td> </td>
      <tr><td>WND_NOSYSMENU </td><td> </td>
      <tr><td>WND_NOSIZEBOX </td><td> </td>
	 </table>
     <br>
	
     <p><strong class="subhead"><a name="Pril3" href="#_Pril3"> Типы бумаги</a></strong></p>
     <table class="tabl1">
      <tr><td>DMPAPER_A3</td><td>A3 297 x 420 mm </td>
      <tr><td>DMPAPER_A4</td><td>A4 210 x 297 mm </td>
      <tr><td>DMPAPER_A5</td><td>A5 148 x 210 mm </td>
      <tr><td>DMPAPER_A6</td><td>A6 105 x 148 mm </td>
	 </table>
     <br>

     <p><strong class="subhead"><a name="Pril4" href="#_Pril4"> Типы градиента в Style</a></strong></p>	
     <table class="tabl1">
      <tr><td>1  </td><td>вертикальный сверху вниз </td>
      <tr><td>2  </td><td>вертикальный снизу вверх </td>
      <tr><td>3  </td><td>горизонтальный слева направо </td>
      <tr><td>4  </td><td>горизонтальный справа налево </td>
      <tr><td>5  </td><td>диагональный справа вверх </td>
      <tr><td>6  </td><td>диагональный слева вниз </td>
      <tr><td>7  </td><td>диагональный справа вниз </td>
      <tr><td>8  </td><td>диагональный слева вверх </td>
      <tr><td>9  </td><td>радиальный градиент </td>
     </table>
     <br>

     <p><strong class="subhead"><a name="Pril5" href="#_Pril5"> Идентификаторы событий</a></strong></p>	
     <p>Здесь приведен список идентификаторов событий, поддерживаемых к моменту написания этого
        руководства - тех идентификаторов, которые можно указать в <i>SetCallBackProc()</i> и <i>SetCallBackFunc()</i>.</p>
     <table class="tabl1">
      <tr><td>oninit </td><td> </td>
      <tr><td>ondestroy </td><td> </td>
      <tr><td>onclick </td><td> </td>
      <tr><td>onsize </td><td> </td>
      <tr><td>onpaint </td><td> </td>
      <tr><td>onrclick </td><td> </td>
      <tr><td>ondblclick </td><td> </td>
      <tr><td>onenter </td><td> </td>
      <tr><td>onposchanged </td><td> </td>
     </table>
     <br>

    <hr>
    <script type="text/javascript" src="js/shCore.js"></script>
    <script type="text/javascript" src="js/shBrushGo.js"></script>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
  </div>
</div>

<div id="footer">
  <div>
    <p> © Copyright 2021. All Rights Reserved.</p>
  </div>
</div>

</body>
</html>
